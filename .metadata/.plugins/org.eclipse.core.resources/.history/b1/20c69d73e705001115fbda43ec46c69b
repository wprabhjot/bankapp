package com.bankapp.service;

import java.math.BigDecimal;

import org.springframework.stereotype.Service;

import com.bankapp.entities.Account;
import com.bankapp.entities.Transaction;
import com.bankapp.enums.ApprovalStatus;
import com.bankapp.exceptions.BankAccountNotFoundException;
import com.bankapp.repo.AccountRepository;
import com.bankapp.repo.TransactionRepository;

import jakarta.transaction.Transactional;

@Service
public class TransactionService {

	private TransactionRepository transactionRepository;
	private AccountRepository accountRepository;

	public TransactionService(TransactionRepository transactionRepository, AccountRepository accountRepository) {
		this.transactionRepository = transactionRepository;
		this.accountRepository = accountRepository;
	}

	private void validateAmount(BigDecimal amount) {
		if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
			throw new IllegalArgumentException("Amount must be greater than zero");
		}
	}

	private static final BigDecimal MANAGER_APPROVAL_LIMIT = new BigDecimal("200000");

	@Transactional
	public Transaction deposit(String accountId, BigDecimal amount, String clerkUserId) {
		validateAmount(amount);
		Account account = accountRepository.findById(accountId)
				.orElseThrow(() -> new BankAccountNotFoundException(accountId));
		account.credit(amount);

		Transaction transaction = Transaction.createDeposit(account, amount, clerkUserId);

		transactionRepository.save(transaction);
		accountRepository.save(account);
		return transaction;
	}

	@Transactional
	public Transaction withdraw(String accountId, BigDecimal amount, String clerkUserId) {
		validateAmount(amount);
		Account account = accountRepository.findById(accountId)
				.orElseThrow(() -> new BankAccountNotFoundException(accountId));
		Transaction transaction;

		if (account.getBalance().compareTo(amount) < 0) {
			throw new IllegalStateException("Insufficient balance");
		}
		boolean requiresApproval = amount.compareTo(MANAGER_APPROVAL_LIMIT) > 0;
		if (requiresApproval) {
			transaction = Transaction.createPendingWithdrawal(account, amount, clerkUserId);
		} else {
			transaction = Transaction.createApprovedWithdrawal(account, amount, clerkUserId);
			account.debit(amount);
			accountRepository.save(account);
		}
		transactionRepository.save(transaction);
		return transaction;
	}

	@Transactional
	public void apporveWithdrawal(String transactionId, String managerId) {
		Transaction transaction = transactionRepository.findById(transactionId)
				.orElseThrow(() -> new IllegalArgumentException("Transaction not found"));

		if (transaction.getApprovalStatus() != ApprovalStatus.PENDING_APPROVAL) {
			throw new IllegalStateException("Transaction is not pending for approval");
		}

		Account account = transaction.getAccount();

		if (account.getBalance().compareTo(transaction.getAmount()) < 0) {
			throw new IllegalStateException("Insufficient balance");
		}
		transaction.approve(managerId);
		account.debit(transaction.getAmount());

		accountRepository.save(account);
		transactionRepository.save(transaction);
	}

	@Transactional
	public void rejectWithdrawal(String transactionId, String managerId) {
		Transaction transaction = transactionRepository.findById(transactionId)
				.orElseThrow(() -> new IllegalArgumentException("Transaction not found"));

		if (transaction.getApprovalStatus() != ApprovalStatus.PENDING_APPROVAL) {
			throw new IllegalStateException("Transaction is not pending for approval");
		}
		transaction.reject(managerId);
		transactionRepository.save(transaction);
	}

//	public void transfer( String senderAccountId,  String receiverAccountId, BigDecimal amount) {
//		if (transferRequestDto.getReceiverAccountId().equals(transferRequestDto.getSenderAccountId())) {
//			throw new IllegalArgumentException("Source and target accounts cannot be the same");
//		}
//
//		Account senderAccount = AccountConverter.convertToAccount(getById(transferRequestDto.getSenderAccountId()));
//		Account receiverAccount = AccountConverter.convertToAccount(getById(transferRequestDto.getReceiverAccountId()));
//
//		senderAccount.setBalance(senderAccount.getBalance().subtract(transferRequestDto.getAmount()));
//		receiverAccount.setBalance(receiverAccount.getBalance().add(transferRequestDto.getAmount()));
//		bankRepo.save(senderAccount);
//		bankRepo.save(receiverAccount);
//	}
	@Transactional
	public void transfer(String senderAccountId, String receiverAccountId, BigDecimal amount, String clerkUserId) {
	    validateAmount(amount);

	    if (senderAccountId.equals(receiverAccountId)) {
	        throw new IllegalArgumentException("Source and target accounts cannot be the same");
	    }

	    // Fetch accounts
	    Account sender = accountRepository.findById(senderAccountId)
	            .orElseThrow(() -> new BankAccountNotFoundException(senderAccountId));
	    Account receiver = accountRepository.findById(receiverAccountId)
	            .orElseThrow(() -> new BankAccountNotFoundException(receiverAccountId));

	    // Check sender balance
	    if (sender.getBalance().compareTo(amount) < 0) {
	        throw new IllegalStateException("Insufficient balance in sender account");
	    }

	    // Debit sender, credit receiver
	    sender.debit(amount);
	    receiver.credit(amount);

	    accountRepository.save(sender);
	    accountRepository.save(receiver);

	    // Record transactions
	    Transaction debitTransaction = Transaction.createTransferDebit(sender, amount, clerkUserId, receiver.getId());
	    Transaction creditTransaction = Transaction.createTransferCredit(receiver, amount, clerkUserId, sender.getId());

	    transactionRepository.save(debitTransaction);
	    transactionRepository.save(creditTransaction);
	}

}
