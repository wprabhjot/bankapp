package com.bankapp.service;

import java.math.BigDecimal;
import java.util.List;

import org.springframework.stereotype.Service;

import com.bankapp.dto.request.DepositRequest;
import com.bankapp.dto.request.WithdrawRequest;
import com.bankapp.dto.response.PendingApprovalResponse;
import com.bankapp.dto.response.TransactionResponse;
import com.bankapp.entities.Account;
import com.bankapp.entities.Transaction;
import com.bankapp.enums.ApprovalStatus;
import com.bankapp.exceptions.BankAccountNotFoundException;
import com.bankapp.mapper.TransactionMapper;
import com.bankapp.repo.AccountRepository;
import com.bankapp.repo.TransactionRepository;

import jakarta.transaction.Transactional;

@Service
@Transactional
public class TransactionService {

	private static final BigDecimal MANAGER_APPROVAL_LIMIT = new BigDecimal("200000");

	private final TransactionRepository transactionRepository;
	private final AccountRepository accountRepository;
	private final TransactionMapper transactionMapper;

	public TransactionService(TransactionRepository transactionRepository, AccountRepository accountRepository,
			TransactionMapper transactionMapper) {
		this.transactionRepository = transactionRepository;
		this.accountRepository = accountRepository;
		this.transactionMapper = transactionMapper;
	}

	private void validateAmount(BigDecimal amount) {
		if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
			throw new IllegalArgumentException("Amount must be greater than zero");
		}
	}

	public TransactionResponse deposit(DepositRequest request) {

		validateAmount(request.getAmount());

		Account account = accountRepository.findById(request.getAccountId())
				.orElseThrow(() -> new BankAccountNotFoundException(request.getAccountId()));

		account.credit(request.getAmount());

		Transaction transaction = Transaction.createDeposit(account, request.getAmount(),
				request.getPerformedByUserId());

		accountRepository.save(account);
		transactionRepository.save(transaction);

		return transactionMapper.toTransactionResponse(transaction);
	}

	public TransactionResponse withdraw(WithdrawRequest request) {
		validateAmount(request.getAmount());
		Account account = accountRepository.findById(request.getAccountId())
				.orElseThrow(() -> new BankAccountNotFoundException(request.getAccountId()));

		if (account.getBalance().compareTo(request.getAmount()) < 0) {
			throw new IllegalStateException("Insufficient balance");
		}

		boolean requiresApproval = request.getAmount().compareTo(MANAGER_APPROVAL_LIMIT) > 0;

		Transaction transaction;

		if (requiresApproval) {
			transaction = Transaction.createPendingWithdrawal(account, request.getAmount(),
					request.getPerformedByUserId());
		} else {
			transaction = Transaction.createApprovedWithdrawal(account, request.getAmount(),
					request.getPerformedByUserId());
			account.debit(request.getAmount());
			accountRepository.save(account);
		}

		transactionRepository.save(transaction);
		return transactionMapper.toTransactionResponse(transaction);
	}

	public void transfer(String senderAccountId, String receiverAccountId, BigDecimal amount, String clerkUserId) {
		validateAmount(amount);

		if (senderAccountId.equals(receiverAccountId)) {
			throw new IllegalArgumentException("Source and target accounts cannot be the same");
		}

		Account senderAccount = accountRepository.findById(senderAccountId)
				.orElseThrow(() -> new BankAccountNotFoundException(senderAccountId));
		Account receiverAccount = accountRepository.findById(receiverAccountId)
				.orElseThrow(() -> new BankAccountNotFoundException(receiverAccountId));

		if (senderAccount.getBalance().compareTo(amount) < 0) {
			throw new IllegalStateException("Insufficient balance in sender account");
		}

		senderAccount.debit(amount);
		receiverAccount.credit(amount);

		accountRepository.save(senderAccount);
		accountRepository.save(receiverAccount);

		Transaction debitTransaction = Transaction.createTransferDebit(senderAccount, amount, clerkUserId,
				receiverAccount.getId());
		Transaction creditTransaction = Transaction.createTransferCredit(receiverAccount, amount, clerkUserId,
				senderAccount.getId());

		transactionRepository.save(debitTransaction);
		transactionRepository.save(creditTransaction);
	}

	public List<TransactionResponse> getTransactionsByAccount(String accountId) {

		accountRepository.findById(accountId).orElseThrow(() -> new BankAccountNotFoundException(accountId));

		return transactionRepository.findByAccountIdWithAccount(accountId).stream()
				.map(transactionMapper::toTransactionResponse).toList();
	}

	public List<TransactionResponse> getTransactionsByClerk(String clerkUserId) {

		return transactionRepository.findByPerformedByUserId(clerkUserId).stream()
				.map(transactionMapper::toTransactionResponse).toList();
	}

	public List<PendingApprovalResponse> getPendingApprovals() {
		return transactionRepository.findByApprovalStatus(ApprovalStatus.PENDING_APPROVAL).stream()
				.map(transactionMapper::toPendingApprovalResponse).toList();
	}
}
